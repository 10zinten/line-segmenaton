# AUTOGENERATED! DO NOT EDIT! File to edit: template_matching.ipynb (unless otherwise specified).

__all__ = ['dmp', 'get_templates', 'mtm', 'get_ocr_output', 'get_symbol', 'get_full_text_annotations', 'resize_boxes',
           'cls_box_into_line', 'find_double_tsek_bf', 'compute_iou', 'get_double_tsek_idx', 'put_whitespaces',
           'rm_running_head', 'rm_noise', 'postprocess', 'str_insert', 'add_double_tsek', 'get_double_tsek_text',
           'get_text_span', 'clean_text_id', 'get_toh', 'map_text_id', 'get_index_layer', 'get_base_text',
           'transfer_anns_with_patch', 'isNSM', 'get_first_char_idx', 'adjust_next_diff', 'transfer_anns_with_diff',
           'parse_double_tsek', 'run']

# Cell
from collections import defaultdict
import cv2
import gzip
import json
import math
from pathlib import Path
import re
import unicodedata

from deskew import determine_skew
import diff_match_patch as dmp_module
from MTM import matchTemplates, drawBoxesOnRGB
import numpy as np
from openpecha.serializers import Serialize
from tqdm import tqdm
from xml.dom import minidom
import yaml
from config import config

# Cell
dmp = dmp_module.diff_match_patch()
dmp.Diff_Timeout = 0

# Cell
def get_templates(path):
    templates = []
    for p in Path(path).iterdir():
        if not p.name.endswith('.png'): continue
        templates.append((p.stem, cv2.imread(str(p))))
    return templates

def mtm(image, templates, show=False, th=0.9):
    if isinstance(image, (str, Path)):
        image = cv2.imread(str(image))
    matches = []
    try:
        hits = matchTemplates(templates, image, score_threshold=th, method=cv2.TM_CCOEFF_NORMED, maxOverlap=0.3)
        for x, y, w, h in list(hits['BBox']):
            matches.append([x, y, x+w, y+h])
        if show: image = drawBoxesOnRGB(image, hits, boxThickness=5, boxColor=(255,0,0))
    except KeyError as ex:
        if ex.args[0] == 'Score':
            print('\t- double tsek not found !')
            return matches

    print(f'\t- no. of double tsek detected: {len(matches)}')
    if show:
        plot(image, sz=(15, 15))

    return matches

# Cell
def get_ocr_output(path):
    imagegroup, img_fn = path.parts[-2:]
    res_fn = config.res_path/imagegroup/f'{img_fn.split(".")[0]}.json.gz'
    return json.load(gzip.open(str(res_fn), 'rb'))

def get_symbol(response):
    for page in response['fullTextAnnotation']['pages']:
        for block in page['blocks']:
            for paragraph in block['paragraphs']:
                for word in paragraph['words']:
                    for symbol in word['symbols']:
                        char = symbol['text']
                        v = symbol['boundingBox']['vertices']
                        box = [v[0]['x'], v[0]['y'], v[2]['x'], v[2]['y']]
                        yield char, box

def get_full_text_annotations(response):
    boxes, text = [], ''
    for char, box in get_symbol(response):
        text += char
        boxes.append(box)
    return boxes, text

def resize_boxes(boxes, old_size):
    "`boxes` are in top-right and bottom-left coord system."
    h, w = old_size[:2]
    h_scale = config.img_size[0]/h
    w_scale = config.img_size[1]/w
    result = []
    for box in boxes:
        # adjust the box
        box[0] *= w_scale
        box[1] *= h_scale
        box[2] *= w_scale
        box[3] *= h_scale
        box = list(map(int, box))
        result.append(box)
    return result

# Cell
def cls_box_into_line(boxes, th=20):
    lines = []
    line = []
    prev_y1 = boxes[0][1]
    for box in boxes:
        if abs(box[1] - prev_y1) < th:
            line.append(box)
        else:
            lines.append(line)
            line = []
            line.append(box)
        prev_y1 = box[1]
    else:
        if line: lines.append(line)
    return lines

# Cell
def find_double_tsek_bf(matched_box, boxes, th=20):
    box_lines = cls_box_into_line(boxes)
    pos = 0
    prev_x1 = 0
    for box_line in box_lines:
        if abs(matched_box[1] - box_line[0][1]) < th:
            for i, box in enumerate(box_line):
                if matched_box[0] > prev_x1 and matched_box[0] < box[0]:
                    pos += i-1
                    return pos
        pos += len(box_line)


def compute_iou(box_arr1, box_arr2):
    x11, y11, x12, y12 = np.split(box_arr1, 4, axis=1)
    x21, y21, x22, y22 = np.split(box_arr2, 4, axis=1)

    xA = np.maximum(x11, np.transpose(x21))
    yA = np.maximum(y11, np.transpose(y21))
    xB = np.minimum(x12, np.transpose(x22))
    yB = np.minimum(y12, np.transpose(y22))
    interArea = np.maximum((xB - xA + 1), 0) * np.maximum((yB - yA + 1), 0)
    boxAArea = (x12 - x11 + 1) * (y12 - y11 + 1)
    boxBArea = (x22 - x21 + 1) * (y22 - y21 + 1)
    iou = interArea / (boxAArea + np.transpose(boxBArea) - interArea)

    return iou


def get_double_tsek_idx(image_path, templates, deskew=False, show_boxes=False):
    # load, deskew and resize the image
    image = cv2.imread(str(image_path))
    old_size = image.shape
    if deskew: image = image_deskew(image)
    image = image = cv2.resize(image, (config.img_size[1], config.img_size[0]))

    # find the double tsek boxes
    matches = mtm(image, templates)

    # Get ocr boxes
    response = get_ocr_output(image_path)
    boxes, text = get_full_text_annotations(response)
    if not matches: return [], text
    boxes = resize_boxes(boxes, old_size)

    # find double tsek char index
    iou_matrix = compute_iou(np.array(matches), np.array(boxes))
    if show_boxes: plot_boxes(image, [boxes, matches])
    idxs = list(np.argmax(iou_matrix, axis=1))
    if 0 in idxs:
        undetected_box_idx = idxs.index(0)
        undetected_box_char_idx = find_double_tsek_bf(matches[undetected_box_idx], boxes)
        idxs[undetected_box_idx] = undetected_box_char_idx
    idxs.sort()
    return idxs, text

# Cell
def put_whitespaces(text):
    result = ''
    for chunk in text.split('།'):
        if chunk:
            result += chunk + '། '
        else:
            result += '།'
    return result

# Cell
def rm_running_head(text):
    r_head_end_idx = text.find('༡')
    if r_head_end_idx >= 0  and r_head_end_idx < 500:
        return text[r_head_end_idx+1:]
    else:
        return text[text.find('།')+1:]

def rm_noise(text):
    'remove numbers and etc'
    text = re.sub(f'\d+', '', text)
    for r in ['=', '|', '“', '”', ']', '）', ')', '》', '>', '©', '–', '-', '༸', ('་ི', '་')]:
        if isinstance(r, tuple):
            text = text.replace(r[0], r[1])
        else:
            text = text.replace(r, '')
    return text

def postprocess(text):
    text = rm_running_head(text)
    text = rm_noise(text)
    for f, t in [('$་','་$'), ('$།', '།$'), ('།་$', '།$')]:
        text = text.replace(f, t)
    text = put_whitespaces(text)
    return text

def str_insert(text, idx, char):
    text = text[:idx] + char + text[idx:]
    return text

def add_double_tsek(text, idxs):
    for i, idx in enumerate(idxs):
        text = str_insert(text, idx+i, config.double_tsek_sym)
    return text

def get_double_tsek_text(text_id, path, start, end, engine):
    ann_text_fn = config.output_tmp_path/f'{text_id}-peydurma-ann_text.txt'
    if ann_text_fn.is_file():
        ann_text = ann_text_fn.read_text()
        if engine == 'diff':
            return '', ann_text
        base_text = ann_text.replace(config.double_tsek_sym, '')
        return base_text, ann_text
    ann_text = ''
    for i, path in enumerate(sorted((path).iterdir()), 1):
        if i <  start: continue
        if i > end: break
        print(f'[INFO] {i+1} - Processing {path.name} ...')
        idxs, text = get_double_tsek_idx(path, templates)
        ann_text += f'\n\n{path.name}' if config.debug else ""
        ann_text += postprocess(add_double_tsek(text, idxs))
    ann_text_fn.write_text(ann_text)
    return base_text, ann_text

# Cell
def get_text_span(node):
    vol, span = '', []
    for loc in node.getElementsByTagName('outline:location'):
        vol = int(loc.attributes['vol'].value)
        span.append(int(loc.attributes['page'].value))
    if not vol:
        return
    return {vol: {'start': min(span), 'end': max(span)}}

def clean_text_id(text_id):
    cats = '  abcd'
    text_id = text_id.strip()
    if text_id == '00':
        return
    elif '-' in text_id:
        id_, cat = text_id.split('-')
        if len(cat) > 1: return
        return f'{id_}{cats[int(cat.strip())]}'
    elif ';' in text_id:
        return text_id.split(';')[0].strip()
    else:
        return text_id

def get_toh(fn):
    maps = defaultdict(list)
    dom = minidom.parse(str(fn))
    for node in dom.getElementsByTagName('outline:node'):
        if node.attributes['type'].value != "text": continue
        for desc_node in node.getElementsByTagName('outline:description'):
            attrs = desc_node.attributes
            if 'type' in attrs and attrs['type'].value == "toh":
                desc_childnodes = desc_node.childNodes
                if not desc_childnodes: break
                text_id = clean_text_id(desc_childnodes[0].data)
                if not text_id: break
                maps[text_id].append(get_text_span(node))
                break
    return maps

# Cell
# toh = get_toh(config.peydurma_meta_fn)

# Cell
def map_text_id(text_id, is_kangyur=False):
    if is_kangyur:
        return f'T{text_id}'
    else:
        return f'D{text_id}'

# Cell
def get_index_layer(path):
    index_layer = yaml.safe_load((path/'index.yml').open())
    return index_layer

# Cell
def get_base_text(text_id, opf_path, index_layer):
    serializer = Serialize(opf_path, text_id=text_id, index_layer=index_layer)
    #base_text = ''.join(serializer.get_text_base_layer().values())
    base_text = list(serializer.get_text_base_layer().values())[0]
    return base_text

# Cell
def transfer_anns_with_patch(base_text, src_text, dest_text):
    "Apply patches computed from `src_text` to `dest_text` on `base_text"
    diffs = dmp.diff_main(src_text, dest_text)
    patches = dmp.patch_make(src_text, diffs)
    ann_text = dmp.patch_apply(patches, base_text)[0]
    double_tsek_idxs = parse_double_tsek(ann_text)
    print(f'\t- Transferred {len(double_tsek_idxs)} out of {len(patches)}')
    return double_tsek_idxs, ann_text

# Cell
def isNSM(char):
    # Detects nonspacing mark characters
    if unicodedata.category(char) == "Mn":
        return True
    return False

# Cell
def get_first_char_idx(text, char):
    """Return first char idx in `text` and -1 of not found

    found har idx is expanded for whitespces after the char.
    """
    is_char_found = False
    idx = -1
    for i in range(len(text)):
        if not is_char_found and text[i] == char:
            is_char_found = True
            idx = i
        elif is_char_found:
            if text[i] != ' ': return i-1
            elif i == len(text)-1: return i
    return idx

# Cell
def adjust_next_diff(i, diffs, ann_text, to_char):
    diff_mode, diff_chunk = diffs[i+1]
    # add chars till next tsek to the ann_text
    first_char_idx = get_first_char_idx(diff_chunk, to_char)
    ann_text += diff_chunk[:first_char_idx+1]
    # remove chars till next tsek from diff[i+1]
    diffs[i+1] = (diff_mode, diff_chunk[first_char_idx+1:])
    return ann_text


def transfer_anns_with_diff(base_text, dest_text):
    ann_text = ''
    diffs = dmp.diff_main(dest_text, base_text, checklines=False)
    for i in range(len(diffs)):
        if diffs[i][0] == -1:
            if config.double_tsek_sym in diffs[i][1]:
                # check for next diff adjustment
                if i < len(diffs)-1:
                    # adjust next diff[i+1] if it's first char is NSM
                    if isNSM(diffs[i+1][1][0]):
                        ann_text = adjust_next_diff(i, diffs, ann_text, config.tsek)

                    # adjust next diff[i+1] if it's first char in tsek
                    elif diffs[i+1][1][0] == config.tsek:
                        ann_text = adjust_next_diff(i, diffs, ann_text, config.tsek)

                    # adjust next diff[i+1] if it's first char in shed
                    elif diffs[i+1][1][0] == config.shed:
                        ann_text = adjust_next_diff(i, diffs, ann_text, config.shed)

                    # adjust next diff[i+1] if its first char is line return
                    elif diffs[i+1][1][0] == '\n':
                        ann_text = adjust_next_diff(i, diffs, ann_text, '\n')

                if len(diffs[i][1]) == 1:
                    ann_text += diffs[i][1]
                else:
                    ann_text += '#'
        else:
            ann_text += diffs[i][1]
    double_tsek_idxs = parse_double_tsek(ann_text)
    print(f'\t- Transferred {len(double_tsek_idxs)} out of {dest_text.count(config.double_tsek_sym)}')
    return double_tsek_idxs, ann_text

# Cell
def parse_double_tsek(text):
    double_tsek_idxs = []
    base_char_idx = 0
    for c in text:
        if c == config.double_tsek_sym:
            double_tsek_idxs.append(base_char_idx)
            continue
        base_char_idx += 1
    return double_tsek_idxs

# Cell
def run(text_id, p_vol_path, opf_path, index_layer, start=1, end=float('inf'), replace=False, engine='diff'):
    print(f'[INFO] Transferring double tsek for {text_id}')
    out_idxs_fn = config.output_path/f'{text_id}-dtsek_idxs.txt'
    ann_text_fn = config.output_path/f'{text_id}-ann_text.txt'
    if not out_idxs_fn.is_file() or replace:
        base_text = get_base_text(text_id, opf_path, index_layer)
        p_base_text, p_ann_text = get_double_tsek_text(text_id, p_vol_path, start, end, engine)
        if engine == 'diff':
            double_tsek_idxs, ann_text = transfer_anns_with_diff(base_text, p_ann_text)
        elif engine == 'patch':
            double_tsek_idxs, ann_text = transfer_anns_with_patch(base_text, p_base_text, p_ann_text)

        out_idxs_fn.write_text('\n'.join(map(str, double_tsek_idxs)))
        ann_text_fn.write_text(ann_text)
    print(f'[INFO] Double tsek indices are save at {config.output_path}')

# Cell
#index_layer = get_index_layer(config.kangyur_opf)

# Cell
# run('T340',
#     config.images_path/'I1PD96856',
#     config.kangyur_opf,
#     index_layer,
#     start=19,
#     end=749,
#     replace=True
# )